create type "public"."notification_type" as enum ('like', 'follow', 'mention', 'system');

create sequence "public"."abouts_id_seq";

create sequence "public"."follows_id_seq";

create table "public"."abouts" (
    "id" bigint not null default nextval('abouts_id_seq'::regclass),
    "user_id" uuid not null,
    "content" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
);


alter table "public"."abouts" enable row level security;

create table "public"."follows" (
    "id" bigint not null default nextval('follows_id_seq'::regclass),
    "follower_id" uuid,
    "following_id" uuid,
    "created_at" timestamp with time zone default now()
);


alter table "public"."follows" enable row level security;

create table "public"."notifications" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid not null,
    "actor_id" uuid,
    "type" notification_type not null,
    "payload" jsonb default '{}'::jsonb,
    "is_read" boolean not null default false,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."notifications" enable row level security;

create table "public"."post_comments" (
    "id" uuid not null default gen_random_uuid(),
    "post_id" uuid,
    "user_id" uuid,
    "parent_id" uuid,
    "content" text not null,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
);


alter table "public"."post_comments" enable row level security;

create table "public"."post_likes" (
    "user_id" uuid not null,
    "post_id" uuid not null,
    "created_at" timestamp with time zone default now()
);


alter table "public"."post_likes" enable row level security;

create table "public"."post_saves" (
    "user_id" uuid not null,
    "post_id" uuid not null,
    "created_at" timestamp with time zone default now()
);


alter table "public"."post_saves" enable row level security;

create table "public"."post_tags" (
    "post_id" uuid not null,
    "tag_id" uuid not null,
    "created_at" timestamp with time zone default now()
);


alter table "public"."post_tags" enable row level security;

create table "public"."posts" (
    "id" uuid not null default gen_random_uuid(),
    "text" text not null,
    "media_urls" text[] default '{}'::text[],
    "category" text not null,
    "sub_category" text not null,
    "author" uuid,
    "created_at" timestamp with time zone default now(),
    "model_name" text not null,
    "model_provider" text,
    "model_provider_slug" text,
    "model_label" text,
    "model_key" text,
    "model_kind" text,
    "category_slug" text,
    "sub_category_slug" text
);


alter table "public"."posts" enable row level security;

create table "public"."profiles" (
    "id" uuid not null,
    "username" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "bio" text,
    "background_image" text,
    "avatar_url" text,
    "full_name" text
);


alter table "public"."profiles" enable row level security;

create table "public"."reports" (
    "id" uuid not null default gen_random_uuid(),
    "reporter_id" uuid not null,
    "target_type" text not null,
    "target_id" uuid not null,
    "reason" text,
    "created_at" timestamp with time zone default now()
);


alter table "public"."reports" enable row level security;

create table "public"."tags" (
    "id" uuid not null default gen_random_uuid(),
    "name" text not null
);


alter table "public"."tags" enable row level security;

create table "public"."waitlist" (
    "id" bigint generated by default as identity not null,
    "email" character varying(255) not null,
    "full_name" character varying(255) not null,
    "created_at" timestamp with time zone default now()
);


alter table "public"."waitlist" enable row level security;

alter sequence "public"."abouts_id_seq" owned by "public"."abouts"."id";

alter sequence "public"."follows_id_seq" owned by "public"."follows"."id";

CREATE UNIQUE INDEX abouts_pkey ON public.abouts USING btree (id);

CREATE UNIQUE INDEX abouts_user_id_key ON public.abouts USING btree (user_id);

CREATE UNIQUE INDEX follows_follower_id_following_id_key ON public.follows USING btree (follower_id, following_id);

CREATE UNIQUE INDEX follows_pkey ON public.follows USING btree (id);

CREATE INDEX idx_posts_category_slug ON public.posts USING btree (category_slug);

CREATE INDEX idx_posts_model_key ON public.posts USING btree (model_key);

CREATE INDEX idx_posts_model_provider_slug ON public.posts USING btree (model_provider_slug);

CREATE INDEX idx_posts_sub_category_slug ON public.posts USING btree (sub_category_slug);

CREATE UNIQUE INDEX notifications_pkey ON public.notifications USING btree (id);

CREATE INDEX post_comments_parent_id_idx ON public.post_comments USING btree (parent_id);

CREATE UNIQUE INDEX post_comments_pkey ON public.post_comments USING btree (id);

CREATE INDEX post_comments_post_id_idx ON public.post_comments USING btree (post_id);

CREATE INDEX post_comments_user_id_idx ON public.post_comments USING btree (user_id);

CREATE UNIQUE INDEX post_likes_pkey ON public.post_likes USING btree (user_id, post_id);

CREATE UNIQUE INDEX post_saves_pkey ON public.post_saves USING btree (user_id, post_id);

CREATE UNIQUE INDEX post_tags_pkey ON public.post_tags USING btree (post_id, tag_id);

CREATE INDEX post_tags_post_id_idx ON public.post_tags USING btree (post_id);

CREATE INDEX post_tags_tag_id_idx ON public.post_tags USING btree (tag_id);

CREATE INDEX posts_author_idx ON public.posts USING btree (author);

CREATE UNIQUE INDEX posts_pkey ON public.posts USING btree (id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX profiles_username_key ON public.profiles USING btree (username);

CREATE UNIQUE INDEX reports_pkey ON public.reports USING btree (id);

CREATE INDEX reports_target_idx ON public.reports USING btree (target_type, target_id);

CREATE UNIQUE INDEX tags_name_key ON public.tags USING btree (name);

CREATE UNIQUE INDEX tags_pkey ON public.tags USING btree (id);

CREATE UNIQUE INDEX waitlist_email_key ON public.waitlist USING btree (email);

CREATE UNIQUE INDEX waitlist_pkey ON public.waitlist USING btree (id);

alter table "public"."abouts" add constraint "abouts_pkey" PRIMARY KEY using index "abouts_pkey";

alter table "public"."follows" add constraint "follows_pkey" PRIMARY KEY using index "follows_pkey";

alter table "public"."notifications" add constraint "notifications_pkey" PRIMARY KEY using index "notifications_pkey";

alter table "public"."post_comments" add constraint "post_comments_pkey" PRIMARY KEY using index "post_comments_pkey";

alter table "public"."post_likes" add constraint "post_likes_pkey" PRIMARY KEY using index "post_likes_pkey";

alter table "public"."post_saves" add constraint "post_saves_pkey" PRIMARY KEY using index "post_saves_pkey";

alter table "public"."post_tags" add constraint "post_tags_pkey" PRIMARY KEY using index "post_tags_pkey";

alter table "public"."posts" add constraint "posts_pkey" PRIMARY KEY using index "posts_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."reports" add constraint "reports_pkey" PRIMARY KEY using index "reports_pkey";

alter table "public"."tags" add constraint "tags_pkey" PRIMARY KEY using index "tags_pkey";

alter table "public"."waitlist" add constraint "waitlist_pkey" PRIMARY KEY using index "waitlist_pkey";

alter table "public"."abouts" add constraint "abouts_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."abouts" validate constraint "abouts_user_id_fkey";

alter table "public"."abouts" add constraint "abouts_user_id_key" UNIQUE using index "abouts_user_id_key";

alter table "public"."follows" add constraint "follows_check" CHECK ((follower_id <> following_id)) not valid;

alter table "public"."follows" validate constraint "follows_check";

alter table "public"."follows" add constraint "follows_follower_id_fkey" FOREIGN KEY (follower_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."follows" validate constraint "follows_follower_id_fkey";

alter table "public"."follows" add constraint "follows_follower_id_following_id_key" UNIQUE using index "follows_follower_id_following_id_key";

alter table "public"."follows" add constraint "follows_following_id_fkey" FOREIGN KEY (following_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."follows" validate constraint "follows_following_id_fkey";

alter table "public"."notifications" add constraint "notifications_actor_id_fkey" FOREIGN KEY (actor_id) REFERENCES auth.users(id) not valid;

alter table "public"."notifications" validate constraint "notifications_actor_id_fkey";

alter table "public"."notifications" add constraint "notifications_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."notifications" validate constraint "notifications_user_id_fkey";

alter table "public"."post_comments" add constraint "post_comments_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES post_comments(id) ON DELETE SET NULL not valid;

alter table "public"."post_comments" validate constraint "post_comments_parent_id_fkey";

alter table "public"."post_comments" add constraint "post_comments_post_id_fkey" FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE not valid;

alter table "public"."post_comments" validate constraint "post_comments_post_id_fkey";

alter table "public"."post_comments" add constraint "post_comments_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."post_comments" validate constraint "post_comments_user_id_fkey";

alter table "public"."post_likes" add constraint "post_likes_post_id_fkey" FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE not valid;

alter table "public"."post_likes" validate constraint "post_likes_post_id_fkey";

alter table "public"."post_likes" add constraint "post_likes_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."post_likes" validate constraint "post_likes_user_id_fkey";

alter table "public"."post_saves" add constraint "post_saves_post_id_fkey" FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE not valid;

alter table "public"."post_saves" validate constraint "post_saves_post_id_fkey";

alter table "public"."post_saves" add constraint "post_saves_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."post_saves" validate constraint "post_saves_user_id_fkey";

alter table "public"."post_tags" add constraint "post_tags_post_id_fkey" FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE not valid;

alter table "public"."post_tags" validate constraint "post_tags_post_id_fkey";

alter table "public"."post_tags" add constraint "post_tags_tag_id_fkey" FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE not valid;

alter table "public"."post_tags" validate constraint "post_tags_tag_id_fkey";

alter table "public"."posts" add constraint "posts_author_fkey" FOREIGN KEY (author) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."posts" validate constraint "posts_author_fkey";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."profiles" add constraint "profiles_username_key" UNIQUE using index "profiles_username_key";

alter table "public"."reports" add constraint "reports_reporter_id_fkey" FOREIGN KEY (reporter_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."reports" validate constraint "reports_reporter_id_fkey";

alter table "public"."reports" add constraint "reports_target_type_check" CHECK ((target_type = ANY (ARRAY['post'::text, 'profile'::text]))) not valid;

alter table "public"."reports" validate constraint "reports_target_type_check";

alter table "public"."tags" add constraint "tags_name_key" UNIQUE using index "tags_name_key";

alter table "public"."waitlist" add constraint "waitlist_email_key" UNIQUE using index "waitlist_email_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  new_username text;
begin
  -- Generate a random username like user_ab12cd34
  new_username := 'user_' || substr(md5(gen_random_uuid()::text), 1, 8);

  insert into public.profiles (id, username)
  values (new.id, new_username);

  return new;
end;
$function$
;

create or replace view "public"."posts_with_comment_count" as  SELECT p.id,
    p.text,
    p.media_urls,
    p.category,
    p.sub_category,
    p.author,
    p.created_at,
    p.model_name,
    count(c.id) AS comment_count
   FROM (posts p
     LEFT JOIN post_comments c ON ((p.id = c.post_id)))
  GROUP BY p.id;


CREATE OR REPLACE FUNCTION public.sync_user_full_name()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  -- On INSERT to auth.users, insert a new profile row (if not exists)
  if (tg_op = 'INSERT') then
    insert into public.profiles (id, full_name)
    values (
      new.id,
      coalesce(
        new.raw_user_meta_data ->> 'display_name',
        new.raw_user_meta_data ->> 'name',
        new.raw_user_meta_data ->> 'full_name',
        new.raw_user_meta_data ->> 'preferred_username',
        new.raw_user_meta_data ->> 'login'
      )
    )
    on conflict (id) do update
      set full_name = excluded.full_name;

    return new;
  end if;

  -- On UPDATE to auth.users, update the profile.full_name
  if (tg_op = 'UPDATE') then
    update public.profiles
    set full_name = coalesce(
        new.raw_user_meta_data ->> 'display_name',
        new.raw_user_meta_data ->> 'name',
        new.raw_user_meta_data ->> 'full_name',
        new.raw_user_meta_data ->> 'preferred_username',
        new.raw_user_meta_data ->> 'login'
      )
    where id = new.id;

    return new;
  end if;

  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.updated_at = now();
  return new;
end;
$function$
;

create policy "Anyone can read abouts"
on "public"."abouts"
as permissive
for select
to public
using (true);


create policy "Users can insert their about"
on "public"."abouts"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Users can update their about"
on "public"."abouts"
as permissive
for update
to public
using ((auth.uid() = user_id));


create policy "Anyone can view follows"
on "public"."follows"
as permissive
for select
to public
using (true);


create policy "Users can follow others"
on "public"."follows"
as permissive
for insert
to public
with check ((auth.uid() = follower_id));


create policy "Users can unfollow"
on "public"."follows"
as permissive
for delete
to public
using ((auth.uid() = follower_id));


create policy "users_insert_own_notifications"
on "public"."notifications"
as permissive
for insert
to public
with check ((user_id = auth.uid()));


create policy "users_select_own_notifications"
on "public"."notifications"
as permissive
for select
to public
using ((user_id = auth.uid()));


create policy "users_update_own_notifications"
on "public"."notifications"
as permissive
for update
to public
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));


create policy "Anyone can read comments"
on "public"."post_comments"
as permissive
for select
to public
using (true);


create policy "Users can delete their own comments"
on "public"."post_comments"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "Users can insert their own comments"
on "public"."post_comments"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Users can update their own comments"
on "public"."post_comments"
as permissive
for update
to public
using ((auth.uid() = user_id));


create policy "Anyone can read likes"
on "public"."post_likes"
as permissive
for select
to public
using (true);


create policy "Users can like"
on "public"."post_likes"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Users can unlike"
on "public"."post_likes"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "Users can save"
on "public"."post_saves"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Users can see their own saved posts"
on "public"."post_saves"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "Users can unsave"
on "public"."post_saves"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "Anyone can read post_tags"
on "public"."post_tags"
as permissive
for select
to public
using (true);


create policy "Post owner can delete post_tags"
on "public"."post_tags"
as permissive
for delete
to public
using ((EXISTS ( SELECT 1
   FROM posts
  WHERE ((posts.id = post_tags.post_id) AND (posts.author = auth.uid())))));


create policy "Post owner can insert post_tags"
on "public"."post_tags"
as permissive
for insert
to public
with check ((EXISTS ( SELECT 1
   FROM posts
  WHERE ((posts.id = post_tags.post_id) AND (posts.author = auth.uid())))));


create policy "Anyone can read posts"
on "public"."posts"
as permissive
for select
to public
using (true);


create policy "Users can delete their own posts"
on "public"."posts"
as permissive
for delete
to public
using ((auth.uid() = author));


create policy "Users can insert their own posts"
on "public"."posts"
as permissive
for insert
to public
with check ((auth.uid() = author));


create policy "Users can update their own posts"
on "public"."posts"
as permissive
for update
to public
using ((auth.uid() = author));


create policy "Anyone can view profiles"
on "public"."profiles"
as permissive
for select
to public
using (true);


create policy "Users can delete their own profile"
on "public"."profiles"
as permissive
for delete
to public
using ((auth.uid() = id));


create policy "Users can insert their own profile"
on "public"."profiles"
as permissive
for insert
to public
with check ((auth.uid() = id));


create policy "Users can update their own profile"
on "public"."profiles"
as permissive
for update
to public
using ((auth.uid() = id));


create policy "Users can create their own reports"
on "public"."reports"
as permissive
for insert
to public
with check ((auth.uid() = reporter_id));


create policy "Users can view their own reports"
on "public"."reports"
as permissive
for select
to public
using ((auth.uid() = reporter_id));


create policy "Anyone can read tags"
on "public"."tags"
as permissive
for select
to public
using (true);


create policy "Authenticated users can insert tags"
on "public"."tags"
as permissive
for insert
to public
with check ((auth.role() = 'authenticated'::text));


create policy "Allow admins full access"
on "public"."waitlist"
as permissive
for all
to public
using (((auth.role() = 'authenticated'::text) AND ((auth.jwt() ->> 'role'::text) = 'admin'::text)));


create policy "Allow insert for anyone"
on "public"."waitlist"
as permissive
for insert
to public
with check (true);


create policy "Allow select own email"
on "public"."waitlist"
as permissive
for select
to public
using (((auth.role() = 'authenticated'::text) AND ((email)::text = (auth.jwt() ->> 'email'::text))));


CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();


CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION handle_new_user();

CREATE TRIGGER sync_user_full_name AFTER INSERT OR UPDATE ON auth.users FOR EACH ROW EXECUTE FUNCTION sync_user_full_name();


  create policy "Public read access to postsBucket"
  on "storage"."objects"
  as permissive
  for select
  to public
using ((bucket_id = 'postsBucket'::text));



  create policy "Users can delete their own avatar"
  on "storage"."objects"
  as permissive
  for delete
  to public
using (((bucket_id = 'avatars'::text) AND (auth.role() = 'authenticated'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));



  create policy "Users can delete their own banner"
  on "storage"."objects"
  as permissive
  for delete
  to public
using (((bucket_id = 'banners'::text) AND (auth.role() = 'authenticated'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));



  create policy "Users can delete their own postsBucket files"
  on "storage"."objects"
  as permissive
  for delete
  to public
using (((bucket_id = 'postsBucket'::text) AND (auth.uid() = owner)));



  create policy "Users can update their own avatar"
  on "storage"."objects"
  as permissive
  for update
  to public
using (((bucket_id = 'avatars'::text) AND (auth.role() = 'authenticated'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));



  create policy "Users can update their own banner"
  on "storage"."objects"
  as permissive
  for update
  to public
using (((bucket_id = 'banners'::text) AND (auth.role() = 'authenticated'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));



  create policy "Users can update their own postsBucket files"
  on "storage"."objects"
  as permissive
  for update
  to public
using (((bucket_id = 'postsBucket'::text) AND (auth.uid() = owner)));



  create policy "Users can upload their own avatar"
  on "storage"."objects"
  as permissive
  for insert
  to public
with check (((bucket_id = 'avatars'::text) AND (auth.role() = 'authenticated'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));



  create policy "Users can upload their own banner"
  on "storage"."objects"
  as permissive
  for insert
  to public
with check (((bucket_id = 'banners'::text) AND (auth.role() = 'authenticated'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));



  create policy "Users can upload to postsBucket"
  on "storage"."objects"
  as permissive
  for insert
  to public
with check (((bucket_id = 'postsBucket'::text) AND (auth.role() = 'authenticated'::text)));



  create policy "Users can view their own avatar"
  on "storage"."objects"
  as permissive
  for select
  to public
using (((bucket_id = 'avatars'::text) AND (auth.role() = 'authenticated'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));



  create policy "Users can view their own banner"
  on "storage"."objects"
  as permissive
  for select
  to public
using (((bucket_id = 'banners'::text) AND (auth.role() = 'authenticated'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));



